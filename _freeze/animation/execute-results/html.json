{
  "hash": "a881c9f544169926db380a91d50277a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Animation\"\nformat: \n  html:\n    eval: false\nexecute: \n  freeze: auto\n---\n\n\n\n\nThe animation was created using ggplot2 in R. \n\nThe data set has 1392 rows, corresponding to each month. However, the sonification lasts about 348 seconds, which means that if we just created a frame containing the plot for each incremental month we would have a frame rate of 1392/348 = 4 frames per second. \n\n4fps is abysmal, so each month actually has 7 or 8 frames each. These frames show the same data but slowly pan over the x-axis to create a nice, smooth panning effect in the final animation. \n\nI will share fully reproducible code when I clean it up a bit-- here's the gist:\n\n\n\n\n\n\n\n\n\n## How long is the sonification?\n\nWe start with the audio file generated in \"Sonification Design\" and build an animation to accompany it. \n\n\n\n\n::: {.cell}\n\n```{.text .cell-code}\nffmpeg -i music_all_parts_sat.mp3 -t 348 -c:a libmp3lame -b:a 192k trimmed_music_new_T.mp3\nffprobe -v error -show_entries format=duration -of csv=\"p=0\" trimmed_music_new_T.mp3 > audio_duration.txt\n```\n:::\n\n\n\n\n\n\n## Define colors for the visualization\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(gganimate)\n\n## load the data used to create the sonification\nload(\"data/monthly_weather\")\nn <- nrow(monthly_weather)\n\n## set colors to be used throughout \ncols <- c(\"max\" = \"red\", \"min\" = \"blue\", \"mean\"=\"grey\", \"Winter\" = \"#2f77c3\", \"Spring\" = \"#61bf9a\", \"Summer\" = \"#f94994\", \"Fall\" =  \"#eb9911\")\n\nmonthly_weather$min_col <- \"blue\"\nmonthly_weather$min_col[1:which.max(monthly_weather$max)] <-  NA\nmonthly_weather$max_col <- \"red\"\nmonthly_weather$max_col[1:which.max(monthly_weather$max)] <-  NA\nmonthly_weather$avg_col <- \"grey\"\nmonthly_weather$avg_col[which.max(monthly_weather$max):(min(which(monthly_weather$year ==1977))-1)] <- NA\n\n## i think i don't need this but keeping until I verify FIXME\n# monthly_weather$window_start = c(rep(1909, times = 60), monthly_weather$year[61:n]-4)\n# monthly_weather$window_end = c(rep(1913, times = 60), monthly_weather$year[61:n]+1)\n\nopacity_matrix <- matrix(rep(\"#00000000\", times = n^2), nrow = n)\ncolor_matrix <- matrix(rep(\"#00000000\", times = n^2), nrow = n)\n\n## Want the opacity of the points to fade out\n## current season is entire\n## last season is 90\n## half year is 80\n## three is 70\n## year ago is 50\n## y ls 40\n## y hy 30\n## y 3s 20\n## 2y 10\n## otherwise 00\n## each row is a frame\n\n\n## Generate opacity matrix\nfor(i in 3:nrow(monthly_weather)){\n  current_season = which(monthly_weather$season_label == monthly_weather$season_label[i])\n  \n  color_matrix[i,1:i] <- monthly_weather$season_color[1:i]\n                          \n  season_window <- data.frame(\n  last_season_end = min(current_season)-c(1, 4, 7, 10, 13, 16, 19, 22),\n  last_season_start = min(current_season)-c(3, 6, 9, 12, 15, 18, 21, 24), \n  opacity = c(90, 80, 70, 50, 40, 30 , 20 , 10)\n  )\n  #if i <24, need to truncate window\n  # only go back floor(i / 3) or current\n  \n  if(i<25){\n    season_window <- season_window[1:floor(i/3),]\n    season_window$last_season_start[season_window$last_season_start ==0] = 1\n  }\n  \n  for(j in 1:nrow(season_window)){\n    idx <- season_window$last_season_start[j]:season_window$last_season_end[j]\n    opacity_matrix[i,idx] <- paste0(color_matrix[i,idx], \n           rep(season_window$opacity[j], times = length(color_matrix[i,idx])))\n  }\n  opacity_matrix[i, current_season] <- color_matrix[i,current_season] \n}\nopacity_matrix[1,1] <- monthly_weather$season_color[1]\nopacity_matrix[2, 1:2] <- monthly_weather$season_color[1:2]\n```\n:::\n\n\n\n\n## Getting the frame rate correct\n\nNote that the audio appears to be at 80bpm rate for some confusing 12/8 reason and/or a MuseScore bug.\n\nWe want to have one year = 4 beats. Each beat is a season, and each month is 1/3 of a beat, since they are grouped into triplets.\n\nSince each beat is 3 data points, this means that each frame should last 0.75/3 = 0.25 seconds in order for things to sync up and give us a video that is 30fps. We want a total of 10440 = 348*30 frames (n frames), where each frame is shown for 0.25 seconds (80 bpm implies 4/3 beats per second which means each beat lasts 0.75 seconds). \n\nSo, we need 10440 frames but only have 1392 data points. Unfortunately for me, 10440/1392 = 7.5 frames per month (per data point), and we can't have half a frame. So, we need half of the months to have 8 frames and half of the months to have 7. I used some support from ChatGPT on this part, although it did initially suggest I do all 8 frames followed by all 7 frames, which meant the animation slowly got out of sync with the audio (I figured out why on my own, though!).\n\n\nWe can also have more duplicates of frames to increase the frame rate and make it look smoother (i.e. 60fps), but will start with this.\n\nIn addition, these frames complicate the panning as well. If we just had 7 or 8 frames exactly the same, it would still look choppy and just have an unnecesarily large file size. So, I dynamically updated the plot limits to plan across the x-axis even while the monthly data point is fixed. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## starting frame:\nstart_date <- as.Date(\"1910-01-01\")\nend_date <- as.Date(\"2025-12-01\")\nn_frames <- 10440\n\nn_data <- n\n\nframe_counts <- rep(c(8,7), length.out = n_data) ## alternate 8 and 7 frames so audio does not get out of sync\n\nnow = NULL\nfor(i in 1:n_data){\n  now = c(now, rep(i, times = frame_counts[i]))\n}\n\n# Create a sequence of 'center' dates over the full data span\nframe_positions <- scales::rescale(1:n_frames, to = c(1, nrow(monthly_weather)))\n\ncenter_dates <- as.Date(\n  approx(x = seq_along(monthly_weather$date), \n         y = as.numeric(monthly_weather$date), \n         xout = frame_positions)$y,\n  origin = \"1970-01-01\"\n)\n\n\nwindow_width_days <- 365.25 * 5  # approx 5 years\nhalf_window <- window_width_days / 2\n\nwindow_starts <- center_dates - half_window\nwindow_ends   <- center_dates + half_window\n\n\n## check windows\nwindow_frame <- data.frame(\n  window_starts, \n  monthly_weather$date[now],\n  center_dates,\n  window_ends, \n  window_ends <center_dates, \n  window_ends < monthly_weather$date[now]\n)\n```\n:::\n\n\n\n\n## Creating the frames\n\nUsing some parallelization, I generated the very many frames and dumped them all into a folder with their filenames in order. \n\nI was getting down to the wire, so ChatGPT also helped me set up the parallelization. The plotting code was designed and iterated on by me (with some occasional help from ChatGPT if I was unsucccessful at fixing errors the \"old fashioned\" way-- by trying to figure it out, then Googling.)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(future.apply)\nlibrary(progressr)\n\nplan(multisession, workers = parallel::detectCores() - 1)\nhandlers(global = TRUE)\nhandlers(\"txtprogressbar\")  # or \"progress\", \"cli\", etc.\n\nwith_progress({\n  p <- progressor(along = 1:n_frames)\n\n  future_lapply(1:n_frames, function(frame) {\n    monthly_weather$point_cols_min <- monthly_weather$point_cols_max <- monthly_weather$point_cols_avg<- opacity_matrix[now[frame],]\n  monthly_weather$point_cols_min[1:which.max(monthly_weather$max)] <-  NA\n  monthly_weather$point_cols_max[1:which.max(monthly_weather$max)] <-  NA\n  monthly_weather$point_cols_avg[which.max(monthly_weather$max):(min(which(monthly_weather$year ==1977))-1)] <- NA\n  \n  ## set up windows for plot\n  plot_dat <- monthly_weather[1:now[frame],] %>%\n  filter(date >= window_starts[frame], date <= window_ends[frame])\n  plot_start <- window_starts[frame]\n  plot_end <- window_ends[frame]\n  plot_lim <- c(plot_start, plot_end)  \n\n\n  \n  plot_curr <-  plot_dat %>%\n    ggplot(aes(x = date))+\n    geom_segment(data = monthly_weather[1:now[frame],] %>% filter(new_max), aes(x = date-2, xend = date+2, y =max, yend = 120, col = paste0(substr(point_cols_max, 1, 7), \"70\")), linewidth = 5 ) + \n    geom_text(data = monthly_weather[1:now[frame],] %>% filter(new_max), aes(xintercept = date, col = substr(point_cols_max, 1, 7), y = 127, label = \"New \\n High\"), size = 10 ) + \n    geom_segment(data = monthly_weather[1:now[frame],] %>% filter(new_min), aes(x = date-2, xend = date+2, y =-5, yend = min, col = paste0(substr(point_cols_max, 1, 7), \"70\")), linewidth = 5 ) + \n    geom_text(data = monthly_weather[1:now[frame],] %>% filter(new_min), aes(xintercept = date, col = substr(point_cols_max, 1, 7), y = -10, label = \"New \\nLow\"), size = 10 ) + \n    geom_line(aes(y = min, color = min_col), linewidth=2) +\n    geom_point(aes(y = min, color = point_cols_min), size = 5) +\n    geom_line(aes(y = max, color = max_col), linewidth=2) +\n    geom_point(aes(y = max, color = point_cols_max), size = 5) +\n    geom_line(aes(y = mean, color = avg_col), linewidth=2) +\n    geom_point(aes(y = mean, color = point_cols_avg), size = 5) +\n    scale_color_identity(name = NULL, guide=\"none\") + \n    theme(axis.text.x = element_text(angle = 25)) +\n    coord_cartesian(xlim = plot_lim) + \n    ggtitle(paste(format(monthly_weather$date[now[frame]], \"%Y\")), \n                                subtitle = monthly_weather$season[now[frame]]) + \n    ylab(\"Temperature (F)\") + xlab(\"Time\") + theme_void(base_size = 12) +\n    theme(\n        plot.background = element_rect(fill = \"grey25\", color = NA),\n        panel.background = element_rect(fill = \"grey25\", color = NA),\n        panel.border = element_blank(),\n        axis.text = element_text(color = \"grey90\"),\n        axis.title = element_text(color = \"grey90\", size = 40),\n        plot.title = element_text(color = \"grey90\", size = 50),\n        axis.ticks.y = element_line(color = \"grey90\"),\n        panel.grid = element_blank(), \n        axis.text.x = element_blank(),\n        axis.text.y = element_text(size = 40, margin = margin(r = 5)),\n        axis.ticks.x = element_blank(), \n        axis.line = element_line(color = \"grey90\"),\n        axis.title.y = element_text(size = 70),\n        axis.title.x = element_text(size = 40),\n        axis.ticks.length = unit(0.25, \"cm\"),         \n        axis.ticks = element_line(size = 1.2), \n        plot.subtitle = element_text(color = monthly_weather$season_color[now[frame]], hjust = 1, margin = margin(r=15), size = 50)\n    )  + \n    scale_y_continuous(breaks = c(0, 25, 50, 75, 100), limits = c(-10, 127))\n  \n    \n  png(sprintf(\"animation/frame_%05d.png\", frame), width = 3840,       # in pixels\n        height = 2160,      # in pixels\n        res = 150,          # dots per inch\n        units = \"px\"    \n      )\n  \n   print(plot_curr)\n   \n   grid.text(\n    \"Min Temp\", \n    x = unit(0.85, \"npc\") - unit(10, \"pt\"),  # 10pt from the right edge\n    y = unit(0.3, \"npc\"),                 \n    just = \"right\",\n    gp = gpar(col = \"blue\", fontsize = 40)\n)\n   \n   grid.text(\n    \"Max Temp\", \n    x = unit(0.85, \"npc\") - unit(10, \"pt\"),  # 10pt from the right edge\n    y = unit(0.7, \"npc\"),                 \n    just = \"right\",\n    gp = gpar(col = \"red\", fontsize = 40)\n)\n   grid.text(\n    \"Avg Temp\", \n    x = unit(0.85, \"npc\") - unit(10, \"pt\"),  # 10pt from the right edge\n    y = unit(0.5, \"npc\"),                 \n    just = \"right\",\n    gp = gpar(col = \"grey\", fontsize = 40)\n)\n   \n   dev.off()\n   \n\n# update date\n    p(sprintf(\"Frame %d\", frame))  # notify progress bar\n    NULL  # or return something if needed\n  },future.packages = c(\"ggplot2\", \"dplyr\"), future.globals = TRUE)\n})\n```\n:::\n\n\n\n\n\n## Create the video\n\nThis creates an animation without any sound.\n\n\n\n\n::: {.cell}\n\n```{.text .cell-code}\nffmpeg -r 30 -start_number 1 -i animation/frame_%05d.png \\\n-c:v libx264 -pix_fmt yuv420p \\\n-movflags +faststart \\\nanimation_only_PENUL2.mp4\n```\n:::\n\n\n\n\n\n## Sync audio\n\nJust to be sure, we trim the music and format it as an .m4a because for some reason I don't really understand that works better.\n\n\nThen, `ffmpeg` creates the final animation and sonification as an .mp4 file. \n\n\n\n\n::: {.cell}\n\n```{.text .cell-code}\nffmpeg -i trimmed_music_new_T.mp3 -t 348.000000 -c:a aac -movflags +faststart trimmed_music_final.m4a\n\n\nffmpeg -i animation_only_PENUL2.mp4 -i trimmed_music_final.m4a \\\n-c:v copy -c:a aac -movflags +faststart -shortest \\\nanimation_synced_PENUL2.mp4\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}